"""
Rules for mapping reads to assembly
"""

###
### Meta rules
###

localrules: map_all_for_target
rule map_all_for_target:
    message:
        "Mapping (with {wildcards.mapper})) {wildcards.target} in {wildcards.dir} done"
    input:
        "{dir}.{mapper}/{target}.{:sources:}.sorted.bam.bai"
    output:
        touch("{dir}.{mapper}/stamp.all_{target}")

localrules: map_all
rule map_all:
    message:
        "Mapping (with {wildcards.mapper})) in {wildcards.dir} done"
    input:
        "{dir}.{mapper}/stamp.all_{:targets:}"
    output:
        touch("{dir}.{mapper}/all")


###
### Mapping with Hisat2
###

rule hisat2_all:
    input: "{dir}.ht2/{:runs:}.sorted.bam.bai"
    output: touch("{dir}.ht2/all")


rule hisat2:
    """
    For hisat we always assume a pre-build index as providing SNPs and haplotypes
    etc is beyond this pipelines scope.

    TODO: allow choosing different references
    """
    message: "Hisat2: mapping "
    input:
        pairs = "{dir}/{source}.{: pairnames :}.fq.gz",
        index = "{:dir.references:}/hisat_GRCh38_snp_tran"
    output:
        bam   = temp("{dir}.ht2/{source}.bam"),
        stats = "{dir}.ht2/{source}.stats",
        unal  = "{dir}.ht2RMgrhc38/{source}.{:pairnames:}.fq.gz"
    log:
                "{dir}.ht2/{source}.log"
    params:
        mem   = icfg.mem("16G"),
        unal  = "{dir}.ht2RMgrhc38/{source}"
    threads:
        16
    conda:
        "hisat2.yml"
    shell:
        "hisat2"
        " -1 {input.pairs[0]}"
        " -2 {input.pairs[1]}"
        " -x {input.index}/genome_snp_tran"
        " --new-summary"
        " --summary-file {output.stats}"
        " --downstream-transcriptome-assembly" #  require longer anchors for de novo splice
        " -p {threads} "
        " --un-conc-gz {params.unal}"
        " 2>{log}"
        " | samtools view -b -o {output.bam} -;"
        "mv {params.unal}.1 {output.unal[0]};"
        "mv {params.unal}.2 {output.unal[1]};"


###
### Sorting
###

rule sambamba_sort:
    message: "Sambamba: Sorting BAM file {input}"
    input:   "{path}.bam"
    output:  "{path}.sorted.bam",
             "{path}.sorted.bam.bai"
    log:     "{path}.sorted.bam.log"
    benchmark: "benchmarks/sambamba_sort/{path}.txt"
    params:  mem=icfg.mem("32g"),
             compress=6
    threads: 8
    conda: "sambamba.yml"
    shell:
        "sambamba sort"
        " --memory-limit={params.mem}MB"
        " --compression-level={params.compress}"
        " --nthreads={threads}"
        " {input}"
        " >{log} 2>&1"
