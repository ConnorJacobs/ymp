"""
  *.blast/ rules

The rules assume that there are files in $workdir containing
query sequences. E.g. "./query.faa". 
"""

# Define which format and values we'd like to have from BLAST
# If you change this, all blast outputs have to be re-run!

BLASTFMT="7 qacc sacc pident length mismatch gapopen qstart qend sstart send evalue bitscore"
BLASTFMT+=" sstrand sframe score"

DBEXT = "nin nhr nsi nsd nsq nog".split(" ")

rule makeblastdb:
    """
    Builds a (temporary) blast index from a fasta file.
    """
    message: "Building Blastdb"
    input:
        "{dir}/{file}.fasta"
    output:
        temp("{dir}.blast/{file}.fasta.nin"),
        temp("{dir}.blast/{file}.fasta.nhr"),
        temp("{dir}.blast/{file}.fasta.nsi"),
        temp("{dir}.blast/{file}.fasta.nsd"),
        temp("{dir}.blast/{file}.fasta.nsq"),
        temp("{dir}.blast/{file}.fasta.nog")
    params:
        out="{dir}.blast/{file}.fasta",
        title="{file}"
    threads:
        1
    conda:
        srcdir("blast.yml")
    shell: """
    makeblastdb -dbtype nucl \
                -parse_seqids \
                -in {input} \
                -out {params.out} \
                -title {params.title}
    """


rule tblastn_query:
    """
    Runs a TBLASTN search against an assembly.
    """
    message:
        "tblastn: searching {wildcards.dir} {wildcards.sample} for {wildcards.query}"
    output:
        "{dir}.blast/{sample}.{query}.blast7"
    input:
        idx = expand("{{dir}}.blast/{{sample}}.fasta.{ext}", ext=DBEXT),
        q   = "{query}.faa"
    params:
        db="{dir}.blast/{sample}.fasta",
        blastfmt=BLASTFMT
    threads:
        8
    conda:
        srcdir("blast.yml")
    shell: """
    tblastn -db {params.db} -query {input.q} \
      -outfmt "{params.blastfmt}" \
      -out {output} \
      -num_threads {threads}
    """

rule tblastn_query_all:
    """
    Collector rule
    """
    message:
        "All blast jobs in {wildcards.dir}.blast completed"
    input:
        "{dir}.blast/{: targets :}.contigs.{query}.blast7"
    output:
        "{dir}.blast/complete_{query}"
    shell:
        "touch {output}"


rule blast7_merge:
    """
    Merges blast results from all samples into single file
    """
    message:
        "Merging BLAST results for {wildcards.query} in {wildcards.dir}"
    input:
        "{dir}.blast/{: targets :}.contigs.{query}.blast7",
    output:
        "{dir}.blast/{query}.{gene}.blast7"
    params:
        re="{dir}.blast/(.+).contigs.{query}.blast7",
        gene="{gene}"
    threads:
        1
    run:
        import fileinput
        sample_re=re.compile(params.re)
        with fileinput.input(input) as f, open(output[0], "w") as out:
            for line in f:
                if f.isfirstline():
                    # extract target name from filename
                    sample = sample_re.match(f.filename()).group(1)
                    
                if line[0] == "#":
                    if "BLAST" in line:
                        header = ""
                    header += line
                elif line.startswith(params.gene):
                    if len(header) > 0:
                        out.write(header)
                        header = ""
                    line_parts = line.split('\t', 1)
                    out.write("".join([line_parts[0], '\t', sample, '_', line_parts[1]]))


rule blast7_extract:
    message:
        "Collecting hits for {wildcards.query}/{wildcards.gene}"
    input:
        expand("{{dir}}.blast/{{sample}}.fasta.{ext}", ext=DBEXT),
        blast="{dir}.blast/{sample}.{query}.blast7"
    output:
        fa="{dir}.blast/{sample}.{query}.{gene}.fasta",
        cs="{dir}.blast/{sample}.{query}.{gene}.csv",
    params:
        re="{dir}.blast/(.+).contigs.{query}.blast7",
        gene="{gene}",
        db="{dir}.blast/{sample}.fasta",
        sample="{sample}"
    threads:
        1
    run:
        import subprocess, csv
        blastfmt = BLASTFMT.split()
        get_field = lambda sline, col: sline[blastfmt.index(col)-1]
        get_fields = lambda sline, cols: (get_field(sline, col) for col in cols)
        with open(input.blast, "r") as blast, \
             open(output.fa,"w") as out, \
             open(output.cs,"w") as out_csv_f:
            out_csv = csv.writer(out_csv_f)
            out_csv.writerow([
                "fasta_id", "sample_id", "sequence_id", "gene_id",
                "start", "end", "evalue", "pident", "length"])
            for line in blast:
                if line[0] == "#": continue
                if not line.startswith(params.gene): continue
                line_parts = line.strip().split('\t')
                sacc, sstart, send = get_fields(line_parts,
                                                ['sacc','sstart','send',])
                qacc, evalue, pident, length = get_fields(line_parts,
                                                          ['qacc','evalue', 'pident', 'length'])
                sstart = int(sstart)
                send = int(send)
                
                seq = subprocess.check_output(
                    ['blastdbcmd',
                     '-db', params.db,
                     '-entry', sacc,
                     '-range', "{}-{}".format(min(sstart,send), max(sstart,send)),
                     '-strand', "plus" if sstart < send else "minus"
                     ]).decode('ascii')
                seqbla, seq = seq.split("\n", 1)
                seq = seq.replace("\n","")
                seqname = "{sample}.{sacc}.{start}.{stop}".format(
                    sample=params.sample,
                    sacc=sacc,
                    start=sstart,
                    stop=send,
                )
                out.write(">{seqname}\n{seq}\n".format(seq=seq, seqname=seqname))
                out_csv.writerow([seqname, params.sample, sacc, qacc,
                                  sstart, send, evalue, pident, length])

        
rule blast7_exctract_merge:
    message:
        "Merging {wildcards.query}/{wildcards.gene}"
    input:
        fa="{dir}.blast/{: targets :}.contigs.{query}.{gene}.fasta",
        csv="{dir}.blast/{: targets :}.contigs.{query}.{gene}.csv"
    output:
        fa="{dir}.blast/{query}.{gene}.fasta.gz",
        csv="{dir}.blast/{query}.{gene}.csv"
    shell: """
    cat {input.fa} | gzip -c9 > {output.fa}

    if test "$(echo {input.csv} | wc -w)" -eq 1; then
       cp {input.csv} {output.csv}
    else
        (
            head -n1 {input.csv[0]};
            tail -n +2 -q {input.csv};
        ) > {output.csv}
    fi
    """


rule blast7_coverage:
    message:
        "Calulating coverage"
    input:
        blast7="{dir}.blast/{target}.contigs.{query}.blast7",
        bam="{dir}.map/{target}.contigs.{source}.bowtie2.sorted.bam",
    output:
        csv="{dir}.blast.cov/{target}.contigs.{source}.{query}.cov"
    log:
        "{dir}.blast.cov/{target}.contigs.{source}.{query}.log"
    shell: """
    ulimit -c 10000000
    metacov {input.bam} {input.blast7} {output.csv}.tmp >{log} 2>&1
    sed -e '1 s/^/target,source,/' \
        -e '2~1 s/^/{wildcards.target},{wildcards.source},/' \
        {output.csv}.tmp > {output.csv}
    rm {output.csv}.tmp
    """

rule blast7_coverage_join_sources:
    message:
        "Merging coverage"
    input:
        csv="{dir}.cov/{target}.contigs.{: sources :}.{query}.cov"
    output:
        csv=temp("{dir}.cov/{target}.contigs.{query}.cov")
    shell: """
    if test "$(echo {input.csv} | wc -w)" -eq 1; then
       cp {input.csv} {output.csv}
    else
        (
            head -n1 {input.csv[0]};
            tail -n +2 -q {input.csv};
        ) > {output.csv}
    fi
    """

rule blast7_coverage_join_targets:
    message:
        "Merging coverage"
    input:
        csv="{dir}.cov/{:targets:}.contigs.{query}.cov"
    output:
        csv="{dir}.cov/{query}.cov"
    shell: """
    if test "$(echo {input.csv} | wc -w)" -eq 1; then
       cp {input.csv} {output.csv}
    else
        (
            head -n1 {input.csv[0]};
            tail -n +2 -q {input.csv};
        ) > {output.csv}
    fi
    """


rule blast7_coverage_per_otu:
    input:
        cov="{dir}.blast/{sample}.{: targets :}.{query}.cov.csv",
        clust="{dir}.blast/{query}.{gene}.NR.csv"
    output:
        otu="{dir}.blast/{sample}.{target}.{query}.{gene}.cova.csv"
    run:
        import csv
        clust_map = {}
        cov_map = {}
        with open(input.clust, "r") as clust_f:
            clust_reader = csv.DictReader(clust_f)
            for row in clust_reader:
                clust_map[row['sacc']] = row['qacc']
        with open(input.cov, "r") as cov_f:
            cov_reader  = csv.DictReader(cov_f)
            for row in cov_reader:
                ref = ".".join([wildcards.sample,
                                row['sacc'], row['start'], row['end']])
                try:
                    cov_map[clust_map[ref]] = row['q23']
                except:
                    pass
            print(repr(cov_map))



##### Reports ##########

rule blast7_reports:
    input:
        "{:reportsdir:}/{dir}.blast.{query}.{gene}.html"
    output:
        touch("{dir}.blast/reports_{query}_{gene}")



rule blast7_eval_hist:
    input:
        "{dir}.blast/{query}.{gene}.blast7"
    wildcard_constraints:
       type="(evalue|bitscore|score|length|pident)"
    output:
        "{dir}.blast/{query}.{gene}.blast7.{type}_hist.pdf"
    run:
        col = BLASTFMT.split().index(wildcards.type)
        from ymp.util import R
        
        R("""
        df <- read.csv("{input}", header=FALSE, sep="\t", comment.char="#")
        minval = min(df[df[,{col}]>0,{col}])
        print(minval)
        print(log10(minval))
        maxval = max(df[,{col}])
        library(ggplot2)

        f = function(x,y) {{x[x == -Inf]=y[1]; x}}
        pdf("{output}")

        g <- ggplot(df, aes(x=V{col})) + \
        geom_histogram(bins=100) + \
        scale_x_log10("{wildcards.gene}",oob=f,minor_breaks=10^seq(0,log10(minval),-1),
                      breaks=10^seq(0,log10(minval),-10)) + \
        scale_y_log10();
        
        dev.off()
        """)


rule blast7_eval_plot:
    input:
        blast7="{dir}.blast/{query}.{gene}.blast7",
        rmd=srcdir("../R/blast.Rmd")
    output:
        "{:reportsdir:}/{dir}.blast.{query}.{gene}.html"
    run:
        colnames = ",".join(BLASTFMT.split()[1:])
        from ymp.util import Rmd
        import os
        print(repr(input.blast7))
        print(repr(output))
        
        Rmd(rmd=input.rmd,
            out=output,
            blast7=os.path.abspath(input.blast7),
            colnames=colnames)
        

